# ðŸ”¥ Spark
_A NodeJS backend template to develop REST applications using fastify_

The setup should be straight forward, the "convention over configuration" is used in favor of fast prototyping;

This template heavily uses fastify and its ecosystem and therefore will be mentioning alot of other packages, specially while covering configuration;

## Features:
- File based "routing" using fastify autoload
- Dependency injection based on parameter names using awilix (the dx need some work here, since we can "mess up" the parameter names!)
- Dev environment using TSX (that uses esbuild) for fast server reloads and transparent "build" step
- Import mapping using package.json "imports" and tsconfig "paths"
- I/O validation using fastify schema + @sinclair/typebox types and compiler ( its based on JSONSchema so AJV can be used, as fastify defaults to ) 
- Type inference using fastify own type provider and type system

## Usage
There are some conventions to "autoload" almost everything needed, avoiding the necessity to write glue/initialization code

### Creating RESTful endpoints
By default all files named as _"+name_of_the_endpoint.(m|c)?(t|j)s"_ inside the _"./routes"_ folder will be autoloaded!  
The file should export as the default a function that satisfies the "fastify-plugin" signature! 

```ts
// file './routes/+hello_world.ts'

export default function (
	fastify : FastifyInstace, 
	options : Record<string, unknown> & { container : AwilixContainer }, 
	done: (err? : Error) => void
) {

	// uses the di container to resolve dependencies
	const dependencyContainer = options.container

	// Create endpoints, add hooks...
	fastify.get('', {})

	// call done when finished loading the routes into the instance 
	done()
}

```
> The "container" is supplied as a global plugin configuration and is an instance of AwilixContainer
#### Creating a single endpoint per file
For a single endpoint inside a file one can use "createRoute" exported from "#core/create_route".  
It expects almost the same options as _"fastify.route()"_, the only difference is the _"useTypeBoxCompiler"_ option which will swap the schema compiler of the route from AJV to the @sinclair/typebox type compiler (which is faster but only supports schemas generated by the package itself!)

```ts
// file './routes/+hello_world.ts'
import { createRoute } from "#core/create_route"

export default createRoute({
	url : '/', // could be ommited, "/" is the default value!
	method : 'GET', // could be ommited, "GET" is the default method! 
	handler(_req, _res) {
		return "Hello world"
	}
})
```

This function is just a quality of life improvement over setting up a plugin and then creating a route, it will also auto inject dependencies into the route handler! 

Example:
```ts
// file : "./config.ts" - Injecting values from config
import { createConfig } from '#core/create_config'
import { asValue } from 'awilix'

export const SparkConfig = createConfig({
	injector : {
		register : {
			'meaningOfLife' : asValue(42)
		}
	}
})

// file: "./lib/+service1.ts" - Injecting services from "./lib"
import { InjectableName } from "#core/inject";

export default class Service1 {
	
	static [InjectableName] = 'service1' // could be ommited, camel case is the default name transformation for awilix!

	sayHy() {
		return 'Hello from service 1'
	}
}

// file './routes/+hello_world.ts'
import { createRoute } from "#core/create_route"
import type { Service1 } from "#lib/+service1"

export default createRoute({
	url : '/', // could be ommited, "/" is the default value!
	method : 'GET', // could be ommited, "GET" is the default method! 
	handler(_req, _res, meaningOfLife : number, service1 : Service1) {
		return `${service1.sayHi()}! The meaning of life is ${meaningOfLife}`
	}
})

```

> The explanation above applies to the default behaviour baked into the template, as said it uses "awilix" module loader and "@fastify/autoload" features and every aspect of it can be customized in the "./config.ts" file

### Dependency Injection
Spark will use awilix as its dependency container / injector  

#### Autoloading services from "./lib"
Just like routes, files inside the "lib" folder which follows some conventions will be avaliable inside the container:
- "+nameOfTheService.ts", will check for default exported values and assign them as "singletons"
- "~nameOfTheService.ts", will check for default exported values and assign them as "transitent"

The name which they will be avaliable is either the class name as camelCase or the value inside the static property symbol [InjectableName];  
Example:
```ts
// file: './lib/+service1.ts' - will be avaliable as a singleton named "service1"
export default class Service1 {

	hiCount = 0;
	
	sayHi() {
		return `${hiCount++} hello from service 1!`
	}

}

// file: './lib/~another_service.ts' - will be avaliable as "service2", transient instance!
import { InjectableName } from "#core/injector"

export default class AnotherService {

	static [InjectableName] = 'service2'

	sayHi() {
		return 'hello from service 2'
	}

}
```

> Since the autoloading is done in the global scope there's no convention from "scoped" lifetime! But autohooks may inject / create a new scoped container for its plugins!